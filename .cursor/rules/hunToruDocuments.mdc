---
description: HunToru アプリ ドキュメント一式
globs:
alwaysApply: true
---

# HunToru アプリ ドキュメント一式

---

## 1. 難易度ドキュメント (更新版)

このドキュメントは、「HunToru」アプリのゲーム体験を定義する難易度システムについて、ユーザーに提供される体験と、開発者が実装・運用するために必要なタスクを明確にします。

### 1.1. 難易度システムの概要

「HunToru」アプリでは、ユーザーが選択できる **3 つの難易度レベル** が提供されます。各難易度では、AI が生成するお題の種類と、そのお題をクリアするために必要な HunToru くんの「太り値」の基準が異なります。これにより、初心者から熟練者まで、あらゆるユーザーが自分のスキルレベルに合わせて挑戦し、達成感を味わえるように設計されています。

### 1.2. ユーザー目線の難易度体験

ユーザーは以下の 3 つの難易度から選択し、それぞれ異なる挑戦を楽しめます。

#### イージー (Easy)

- **特徴**: 最も手軽に楽しめる難易度。初めての方や、気軽に成功体験を味わいたい方に最適です。
- **お題**: 「何か **丸いもの** を撮ろう！」「何か **光るもの** を撮ろう！」のように、**モノの「属性」** に関するお題が出題されます。家にあるあらゆるモノの中から、お題の属性に合うものを探すことができます。
- **クリア条件**: 1 ゲーム（3 つのお題）をプレイした後、HunToru くんの最終的な「太り値」が**2.0 以上**であればクリアです。比較的簡単な属性のお題が多く、HunToru くんを太らせやすい難易度です。

#### ノーマル (Normal)

- **特徴**: 適度な挑戦と達成感を提供する標準的な難易度。ゲームの基本操作に慣れた方に適しています。
- **お題**: 「**コップ** を撮ろう！」「**本** を撮ろう！」のように、**具体的な「モノ」** に関するお題が出題されます。
- **クリア条件**: 1 ゲーム（3 つのお題）をプレイした後、HunToru くんの最終的な「太り値」が**2.5 以上**であればクリアです。具体的なモノの認識にはある程度の精度が求められますが、ユーザーの工夫次第で高スコアを狙い、太り値を効率的に増やせます。

#### ハード (Hard)

- **特徴**: 高度な観察力と撮影スキルが求められる、やり込み要素満載の難易度。最高の達成感を求める方に最適です。
- **お題**: 「**赤いコップ** を撮ろう！」「**木製のスプーン** を撮ろう！」のように、**「形容詞 ＋ モノ」** という、特定の属性を持つモノに関するお題が出題されます。
- **クリア条件**: 1 ゲーム（3 つのお題）をプレイした後、HunToru くんの最終的な「太り値」が**3.0 以上**であればクリアです。特定の属性を持つモノの認識には非常に高い精度が求められます。完全に一致するモノがなくても、ユーザーが**工夫して色味や質感、形状などが似ているモノを撮影**し、AI が高いスコアを出せば太り値を大きく増やせる可能性があります。最高のスコアを目指して、撮影の腕前を磨きましょう。

### 1.3. 開発者目線の実装・運用タスク

難易度システムを効果的に実装し、運用するために、以下のタスクが必要です。

#### 1.3.1. お題リストの作成と管理

- **イージー**:
  - **タスク**: AI が認識できる「形容詞」に紐づく、幅広いカテゴリの**「抽象的なラベル群」**を選定し、リスト化します。
  - **例**: "Circle", "Soft", "Light source", "Transparent", "Shiny" など。これらと関連する AI ラベルの対応表を作成。
- **ノーマル**:
  - **タスク**: AI が認識しやすい、一般的な**「具体的なモノのラベル」**を多数リスト化します。
  - **例**: "Cup", "Spoon", "Book", "Remote control", "Chair", "Table", "Smartphone" など。
- **ハード**:
  - **タスク**: AI が認識できる「形容詞」と「モノ」の組み合わせで、**「形容詞＋モノ」の具体的なお題** と、それに対応する **AI ラベルおよび画像プロパティの組み合わせ条件** をリスト化します。
  - **例**: "赤いコップ" → (`"Cup"` または `"Drinkware"` の高スコア AND `Dominant Colors` に赤系高比率)
  - **注意**: Vision API の**ロゴ検出**、**画像プロパティ** (`Dominant Colors`, `Crop Hints` など) の活用を検討。

#### 1.3.2. AI 判定ロジックの実装

- **Vision API 連携**: Google Cloud Vision API への画像送信と、返却されるラベル (`description`, `score`, `mid`) および画像プロパティのパース処理を実装。
- **お題ごとの判定条件**:
  - 各お題に対して、Vision API から返却されたラベルの中で、**お題の条件に合致すると判断されたラベルのスコアを** HunToru くんの太り値計算に利用します。
  - **例**: `label_score`が 0.2 の場合、HunToru くんの太り値に 1.2 倍を掛けます。
  - **イージー**: 抽象的なラベル群のいずれか一つが検出された場合、そのお題に最も合致するラベルのスコアを利用。
  - **ノーマル**: 具体的なモノのラベルが検出された場合、そのお題に最も合致するラベルのスコアを利用。関連性の高い上位ラベルで高いスコアが出た場合も、そのスコアを代替として利用。
  - **ハード**: 特定のモノのラベルと属性が両方検出された場合、それらの条件を満たす最も合致するラベルのスコア（複合的な評価スコア）を`label_score`として利用。

#### 1.3.3. アプリケーションロジック

- **難易度選択 UI**: ユーザーがイージー、ノーマル、ハードを選択できる UI の実装。
- **お題のランダム生成**: 選択された難易度に基づき、対応するお題リストからランダムに 3 つのお題を生成し表示する機能。
- **画像撮影機能**: スマートフォンのカメラを使用した画像撮影機能の実装。
- **HunToru くんの太り値管理**:
  - ゲーム開始時に `HunToru_debu_value` をデフォルト値（1）にリセット。
  - 各お題のクリア判定後、検出された`label_score`に基づき `HunToru_debu_value` を更新。
- **ゲームクリア判定**: **3 つのお題をプレイした後**、最終的な`HunToru_debu_value`が、選択された難易度ごとの基準値（イージー: 2.0, ノーマル: 2.5, ハード: 3.0）以上であればゲームクリアとする。
- **HunToru くんの状態変化**: `HunToru_debu_value`に応じて、HunToru くんの見た目や状態（太る／痩せる）が変化するアニメーションや画像切り替えの実装。
- **ユーザーフィードバック**: 各お題ごとのスコア表示、獲得スコアの表示、なぜスコアが低かったかのヒント（例: 「コップは認識できましたが、赤色ではありませんでした」など）の実装。ゲーム終了時の最終的な太り値とクリア/失敗の表示。

#### 1.3.4. テストと調整

- **AI 認識の精度テスト**: 各お題で、様々な光条件、角度、背景で撮影された画像を Vision API にかけ、期待通りのラベルとスコアが返されるかを**徹底的に検証**します。特にハードモードの属性付きお題は入念なテストが必要です。
- **太り値のバランス調整**: ユーザーテストを通じて、`HunToru_debu_value`の増減量がゲームバランスとして適切か、各難易度のクリア基準値が体感的に適切かを確認し、必要に応じて調整します。
- **お題のバリエーション追加**: ユーザーが飽きないように、定期的にお題リストの追加・更新を行います。
- **誤認識への対応**: AI が誤認識した場合のユーザー体験を考慮し、スキップ機能やリトライ機能、ヒント機能などを充実させます。

---

## 2. お題生成ドキュメント

このドキュメントは、「HunToru」アプリ内でユーザーに提示されるお題の生成システムについて、そのコンセプト、ユーザー体験、そして開発に必要な実装・運用タスクを定義します。

### 2.1. お題生成システムの概要

「HunToru」アプリのお題生成システムは、選択された難易度に基づき、Google Cloud Vision API の特性を最大限に活用してお題を動的に生成します。ユーザーは常に新鮮で挑戦的なお題に遭遇し、飽きることなくゲームを楽しめます。各ゲームラウンドでは、ユーザーが選択しやすいよう、**3 つのお題が同時に提示**されます。

### 2.2. ユーザー目線のお題生成体験

ユーザーはゲーム開始時に選択した難易度に応じて、異なるタイプのお題が 3 つ提示されます。これにより、ユーザーは自分に合ったお題を選んで挑戦できます。

#### イージー (Easy)

- **お題の形式**: 「何か**形容詞**なモノを撮ろう！」
- **提示例**:
  1.  「何か**丸いもの**を撮ろう！」
  2.  「何か**光るもの**を撮ろう！」
  3.  「何か**柔らかいもの**を撮ろう！」
- **体験**: 比較的広い範囲のモノが対象となるため、家にある様々なモノを試すことができます。どれも簡単な属性なので、サッと見つけて挑戦できます。

#### ノーマル (Normal)

- **お題の形式**: 「**具体的なモノ**を撮ろう！」
- **提示例**:
  1.  「**コップ**を撮ろう！」
  2.  「**本**を撮ろう！」
  3.  「**リモコン**を撮ろう！」
- **体験**: 日常的によく見かけるモノが中心ですが、イージーよりも具体性が増します。複数の候補から、AI が認識しやすいモノや、自分が早く見つけられるモノを選んで挑戦できます。

#### ハード (Hard)

- **お題の形式**: 「**形容詞 ＋ 具体的なモノ**を撮ろう！」
- **提示例**:
  1.  「**赤いコップ**を撮ろう！」
  2.  「**木製のスプーン**を撮ろう！」
  3.  「**開いている本**を撮ろう！」
- **体験**: 特定の属性を持つモノを探すため、より観察力と工夫が求められます。3 つのお題の中から、最も自信のあるものや、ひらめきが働くものを選んで挑戦する戦略性が生まれます。

### 2.3. 開発者目線のお題生成タスク

お題の適切な生成と提示のためには、以下のタスクが必要です。

#### 2.3.1. お題データベースの設計と構築

各難易度のお題を格納するデータベース（または設定ファイル）を設計・構築します。

- **共通構造**: 各お題には少なくとも以下の情報を含めます。

  - `id`: ユニークなお題 ID
  - `difficulty_level`: 難易度（`EASY`, `NORMAL`, `HARD`）
  - `display_text`: ユーザーに表示するお題テキスト（例: "赤いコップを撮ろう！"）
  - `ai_conditions`: AI 判定のための条件（後述）

- **AI 判定条件の詳細 (`ai_conditions`)**:
  - **イージー**:
    - **種類**: 抽象的な属性を示す AI ラベルのリスト。
    - **例**: `[{ "label": "Circle", "score_threshold": 0.0 }]`
    - **補足**: 複数の関連ラベルのいずれかが検出された場合、そのお題に最も合致するラベルのスコアを太り値計算に利用。
  - **ノーマル**:
    - **種類**: 具体的なモノを示す AI ラベル。場合によっては、上位カテゴリや類似ラベルでの代替条件も設定。
    - **例**: `[{ "label": "Cup", "score_threshold": 0.0, "alternates": [ { "label": "Drinkware", "score_threshold": 0.0 } ] }]`
    - **補足**: 検出された最も合致するラベルのスコアを太り値計算に利用。
  - **ハード**:
    - **種類**: 特定のモノのラベルと、その属性を示すラベルや画像プロパティの組み合わせ。
    - **例**: `[{ "label": "Cup", "score_threshold": 0.0, "properties": [{ "type": "COLOR", "value": "RED", "min_ratio": 0.0 }] }]`
    - **補足**: `COLOR` は Vision API の`imagePropertiesAnnotation.dominantColors.colors`の情報を参照。`"value": "RED"` は、事前に定義された RGB 値の範囲や色相の閾値で「赤色系」と判断するロジックを別途用意。複数の条件が満たされた場合の複合的な評価スコアを太り値計算に利用。
    - **AI の認識精度テスト結果に基づく調整が必須**。

#### 2.3.2. お題生成ロジックの実装

選択された難易度に基づき、3 つのお題をデータベースから選択・提示するロジックを実装します。

- **難易度フィルター**: ユーザーが選択した難易度レベルに合致するお題のみをフィルターする。
- **ランダム選択**: フィルターされたお題の中から、重複しないように**ランダムに 3 つのお題を選択**する。
- **履歴管理 (オプション)**: ユーザーが直近でプレイしたお題や、クリアできなかったお題は、一定期間重複しないようにする仕組みを検討し、ユーザー体験の向上を図る。
- **お題数の確保**: 各難易度レベルで、常に 3 つ以上のお題が提供できるよう、十分な数のお題がデータベースに登録されていることを確認する。

#### 2.3.3. 表示と連携

- **UI 表示**: 選択された 3 つのお題を、ユーザーフレンドリーな形で画面に表示する UI を実装。
- **AI 判定ロジックへの連携**: ユーザーが選択したお題に対応する `ai_conditions` を、画像認識後の AI 判定ロジックに正確に渡せるように設計する。

### 2.4. 運用と改善

- **お題の追加・更新**: ユーザーの飽き防止や、Vision API の精度向上に合わせて、定期的にお題を追加・更新できる運用体制を確立。
- **AI 認識精度の監視**: 実稼働後の AI 判定結果をログなどで監視し、お題と実際の認識の乖離がないか、また、ユーザーの「工夫」が適切に評価されているかをチェックする。必要に応じて `ai_conditions` やスコア閾値を微調整する。

---

## 3. 撮影ドキュメント

このドキュメントは、「HunToru」アプリにおけるユーザーの撮影体験と、その実装・運用に必要な開発タスクを定義します。ユーザーは提示されたお題に対し、スマートフォンを使って 1 分以内に最適な画像を撮影し、HunToru くんに食べさせます。

### 3.1. 撮影システムの概要

「HunToru」アプリの撮影システムは、ユーザーが選択したお題に対応する画像をスマートフォンで撮影し、その画像を AI 判定システムへ送るための基盤となります。ユーザーは与えられた時間の中で、最も効果的にお題を捉える写真の撮影に挑戦します。

### 3.2. ユーザー目線の撮影体験

ユーザーはゲームプレイ中、以下のような撮影体験をします。

#### お題表示と準備

- ゲームが開始され、3 つのお題が提示されます。
- ユーザーがその中から 1 つのお題を選択すると、撮影画面へ遷移します。
- 撮影画面では、選択したお題が常時表示され、ユーザーはこれを参考に撮影対象を探します。

#### 1 分間の撮影挑戦

- 撮影画面に切り替わると同時に、**1 分間のカウントダウンタイマーが開始**されます。
- ユーザーはこの 1 分間という制限時間内に、お題に合ったモノを見つけ、**スマートフォンのカメラで撮影**します。
- シャッターボタンは常に利用可能で、ユーザーは納得がいくまで何度でも撮り直しができます。しかし、時間切れになると最後の写真が自動的に選ばれて AI に送られます。
- 撮影時には、AI が認識しやすいよう、**明るさや構図のヒント**（例：「明るい場所で撮ろう！」「モノを大きく写そう！」）が画面上に表示されることがあります。

#### 撮影後の AI 判定

- 1 分間の制限時間が終了するか、ユーザーが任意で「これで OK！」などのボタンを押すと、撮影された最新の画像が AI 判定システムに自動で送られます。
- その後、AI による画像認識とスコア判定が実行され、結果に応じて HunToru くんが変化します。

### 3.3. 開発者目線の実装・運用タスク

撮影システムを効果的に実装し、ユーザーにスムーズな体験を提供するためには、以下のタスクが必要です。

#### 3.3.1. カメラ機能の実装

- **カメラアクセス権限**: アプリ起動時にカメラへのアクセス許可をユーザーに求める機能を実装します。
- **プレビュー表示**: スマートフォンのカメラ映像をリアルタイムでアプリ画面に表示する機能を実装します。
- **シャッター機能**: ユーザーが画像を撮影するためのシャッターボタンの実装。撮影した画像は一時的に保存されるか、メモリ上に保持されます。
- **フラッシュ制御 (オプション)**: 必要に応じて、ユーザーがフラッシュの ON/OFF を切り替えられる機能を実装します。

#### 3.3.2. 撮影時間管理の実装

- **タイマー表示**: 1 分間のカウントダウンタイマーを画面上に表示する UI を実装します。ユーザーが残り時間を視覚的に確認できるよう、残り時間が少なくなると色が変わるなどの工夫も検討します。
- **時間切れ処理**: タイマーがゼロになった際に、自動的に現在のプレビュー画像をキャプチャし、AI 判定プロセスに移行するロジックを実装します。
- **途中終了オプション**: ユーザーが時間内でも撮影を終えたい場合に、「撮影完了」や「これで決定」といったボタンを用意し、AI 判定プロセスへ移行させる機能を実装します。

#### 3.3.3. 撮影画像の最適化と送信

- **画像圧縮**: 撮影された画像は、Vision API への送信前に適切なサイズに圧縮します。高解像度すぎる画像は API への負荷と通信時間を増やすため、適切なリサイズ（例: 最長辺 1280px など）と圧縮（JPEG 品質調整）を適用します。これにより、API レスポンスの高速化とデータ通信量の削減を図ります。
- **画像形式**: Vision API が推奨する画像形式（JPEG、PNG など）で送信されるようにします。
- **Vision API への送信**: 撮影された画像を、Google Cloud Vision API のエンドポイントへ安全かつ効率的に送信する処理を実装します。

#### 3.3.4. ユーザー補助機能 (UX 向上)

- **お題の常時表示**: 撮影画面の視認性の良い位置に、現在のお題テキストを常に表示します。
- **ヒントの表示**: AI が認識しやすい撮影のコツ（例：「明るく撮ろう」「対象物を真ん中に」「ブレないように」など）を、状況に応じて表示する機能を検討します。これは特にノーマルやハードモードで有効です。
- **撮影ガイドライン (オプション)**: 画面上にグリッド線や水平器などを表示し、ユーザーが構図を取りやすくする機能を検討します。

#### 3.3.5. テストとパフォーマンス最適化

- **カメラの互換性テスト**: 多種多様な Android/iOS デバイスでカメラ機能が正常に動作するかをテストします。
- **画像処理速度のテスト**: 撮影から AI 送信、判定までの時間がユーザーを待たせない妥当な速度で行われるかテストし、ボトルネックがあれば最適化します。
- **通信環境の影響テスト**: Wi-Fi 環境だけでなく、モバイルデータ通信環境でもスムーズに動作するかをテストします。

---

## 4. 画像処理ドキュメント

このドキュメントは、「HunToru」アプリがユーザーによって撮影された画像をどのように処理し、AI による評価を経て、最終的に HunToru くんのリアクションに繋げるかを定義します。画像処理は、AI 判定の精度とユーザー体験の品質を左右する重要なフェーズです。

### 4.1. 画像処理システムの概要

「HunToru」アプリの画像処理システムは、ユーザーが撮影した画像を Google Cloud Vision API に送信し、その応答を解析することで、お題に対する画像の適合性を評価します。この評価に基づいて、HunToru くんが「食べる」対象の画像が切り抜かれ、最終的にキャラクターのアクションに反映されます。

### 4.2. ユーザー目線の画像処理体験

ユーザーは、撮影後の見えないバックエンドで、以下のような処理が行われていることを体験します。

#### AI による評価の待ち時間

- 撮影が完了すると、アプリは短時間「AI が評価中…」のような表示を出し、AI による画像認識の処理を待ちます。この時間は、通信環境や画像の複雑さによって変動する可能性がありますが、ユーザーがストレスを感じない範囲での迅速な処理を目指します。

#### 撮影結果の表示とフィードバック

- AI による評価が完了すると、撮影した画像に対する**AI 判定スコア**（例: 「スコア: 0.75」）が表示されます。
- 同時に、お題に対して**成功したか、失敗したか**が明確に示されます。
- 失敗した場合は、「なぜスコアが低かったのか」に関する**ヒント**（例: 「コップは認識できましたが、赤色ではありませんでした」）が表示され、次の挑戦に活かせる情報が得られます。

#### HunToru くんのアクション

- 判定結果に基づき、HunToru くんが画像を「食べる」アニメーションが再生されます。
- 食べられたモノは、AI によって識別・切り抜きされたものが中心となります。
- 食べたモノのスコアに応じて HunToru くんの見た目（太る/痩せる）が変化し、ユーザーは自分の撮影がキャラクターに与える影響を視覚的に確認できます。

### 4.3. 開発者目線の実装・運用タスク

画像処理システムを正確かつ効率的に実装・運用するためには、以下のタスクが必要です。

#### 4.3.1. 画像の前処理 (クライアント/サーバーサイド)

- **画像の圧縮・リサイズ**: 撮影直後に、Google Cloud Vision API に送信する前に、画像のファイルサイズを最適化します。高解像度すぎる画像は API への負荷と通信時間を増やすため、適切なリサイズ（例: 最長辺 1280px など）と圧縮（JPEG 品質調整）を適用します。これにより、API レスポンスの高速化とデータ通信量の削減を図ります。
- **画像形式の統一**: Vision API が推奨する形式（JPEG、PNG など）に統一し、必要に応じて変換します。
- **Exif データ処理 (オプション)**: 必要に応じて画像の向き（回転情報）を Exif データから読み取り、Vision API に送信する前に画像を正しく回転させます。

#### 4.3.2. Google Cloud Vision API との連携

- **API リクエストの構築**: 撮影された画像データを Vision API の`LABEL_DETECTION`、`IMAGE_PROPERTIES`、`WEB_DETECTION`（ロゴ検出用）などの機能リクエストに含めて送信するロジックを実装します。ハードモードの「形容詞＋モノ」のようなお題では、`IMAGE_PROPERTIES`（色情報など）の利用が必須となります。
- **API レスポンスの受信とパース**: Vision API からの JSON レスポンスを受信し、必要な情報（ラベルの`description`、`score`、`mid`、画像プロパティ、ロゴ情報など）を正確にパースします。
- **エラーハンドリング**: API リクエストの失敗、ネットワークエラー、API 制限の超過など、様々なエラーケースに対する適切なエラーハンドリングとリトライメカニズムを実装します。

#### 4.3.3. AI 判定ロジックの実行

- **お題とのマッチング**: お題生成ドキュメントで定義された`ai_conditions`（AI 判定条件）と、Vision API から得られたラベル・スコア・画像プロパティを照合し、お題がクリアされたかどうかを判定します。
  - 各お題に対して、Vision API から返却されたラベルの中で、**お題の条件に合致すると判断されたラベルのスコアを** HunToru くんの太り値計算に利用します。
  - **イージー**: 抽象的なラベル群のいずれかが検出された場合、そのお題に最も合致するラベルのスコアを利用。
  - **ノーマル**: 具体的なモノのラベルが検出された場合、そのお題に最も合致するラベルのスコアを利用。関連性の高い上位ラベルで高いスコアが出た場合も、そのスコアを代替として利用。
  - **ハード**: 特定のモノのラベルが高スコア AND 関連する属性を示すラベルや画像プロパティが条件を満たせば、それらの条件を満たす最も合致するラベルのスコア（複合的な評価スコア）を`label_score`として利用。
- **スコア算出**: AI から返されたスコアのうち、お題と最も合致すると判断されたラベルのスコアを最終スコアとします。
- **クリア/失敗判定**: 算出されたスコアが、HunToru くんの太り値計算に利用される条件（0.3）を満たすかどうかも同時に判定します。

#### 4.3.4. 画像の切り抜き加工 (Cropping)

- **オブジェクト検出の活用 (オプション/発展的)**: Vision API の`OBJECT_LOCALIZATION`機能を利用し、画像内で検出された主要な対象物（例: 「コップ」）のバウンディングボックス（位置情報）を取得します。
- **自動切り抜き**: 取得したバウンディングボックスの情報を基に、対象のモノが写っている部分を自動で切り抜く処理を実装します。これにより、HunToru くんが「食べる」画像が、ユーザーが意図したモノに集中したものになります。
- **Fallback 処理**: `OBJECT_LOCALIZATION`が利用できない、または特定のオブジェクトが検出されなかった場合は、撮影された画像全体、または中央部分を切り抜くなどの代替処理を用意します。

#### 4.3.5. HunToru くんへのデータ連携と UI 更新

- **結果の連携**: 最終的な AI 判定スコア、そして切り抜かれた画像データを HunToru くんのキャラクター制御ロジックへ連携します。
- **UI 表示**: 判定結果に応じて、スコア表示、ヒント表示、そして HunToru くんのアニメーションや見た目の変化をスムーズに更新する UI ロジックを実装します。

#### 4.3.6. テストと最適化

- **認識精度と判定ロジックの検証**: 様々なテスト画像（成功例、失敗例、微妙な例）を用いて、AI 判定ロジックが期待通りに機能するかを厳密にテストします。特にハードモードの複合条件は入念にテストを行います。
- **処理速度の最適化**: 画像の圧縮から API 送信、レスポンス受信、判定、切り抜きまでの全体的な処理速度を計測し、ユーザーが快適に感じるレベル（数秒以内）に収まるよう最適化します。
- **ネットワーク耐性**: 不安定なネットワーク環境下でも、タイムアウト処理やリトライ処理が適切に機能するかをテストします。

---

## 5. キャラクタードキュメント: HunToru くん (更新版)

このドキュメントは、「HunToru」アプリのメインキャラクターである「HunToru くん」について、そのデザインコンセプト、ユーザーとのインタラクション、そして AI 判定結果に応じた変化の仕組みを定義します。HunToru くんは、ユーザーのゲームプレイに直接反応し、視覚的なフィードバックを通じて継続的なモチベーションを促す重要な要素です。

### 5.1. キャラクターシステムの概要

HunToru くんは、ユーザーが撮影し、AI が評価した「モノ」を「食べる」ことで成長・変化するインタラクティブなキャラクターです。彼の変化は、ユーザーの撮影スキルやゲームの難易度選択によってダイナミックに反映され、ユーザーがゲームに没入し、愛着を感じるための中心的な存在となります。

### 5.2. ユーザー目線の HunToru くん体験

ユーザーは HunToru くんを通じて、自分の行動がキャラクターに直接影響を与えるユニークな体験をします。

#### HunToru くんの誕生と存在

- アプリの起動やゲーム開始時に、愛らしい HunToru くんが登場し、ユーザーを歓迎します。
- 彼は常に画面上に存在し、ユーザーのゲームプレイを見守っているような存在感を与えます。

#### 撮影したものを「食べる」アクション

- ユーザーが撮影を終え、AI の判定が完了すると、HunToru くんはユーザーが撮影した**対象のモノ（AI が切り抜いた画像）を本当に「食べる」**かのようなアニメーションを見せます。
- 食べる仕草は、モノの種類や大きさによってコミカルに変化するなど、見ていて楽しい演出を目指します。

#### スコアに応じた HunToru くんの変化

- HunToru くんの最も特徴的な点は、食べたモノの**AI 判定スコアに応じて見た目が変化する**ことです。
- 具体的には、AI 判定スコア `label_score` に応じて、HunToru くんは「太る」または「痩せる」といった変化を見せます。
- `label_score` が高いほど、HunToru くんは大きく太り（例: 体が膨らむ、色が鮮やかになる、表情が生き生きとする、アクセサリーが増えるなど、健康で幸せそうな姿になります）、`label_score` が低いほど、痩せるか、または元気がなくなる変化を見せます（例: 体がしぼむ、色がくすむ、表情が悲しげになるなど）。
- この変化は、ユーザーのプレイ結果がダイレクトにキャラクターに反映されるため、**「次はもっと良い写真を撮って HunToru くんを太らせてあげよう！」**というモチベーションに繋がります。

#### バリエーション豊かな変化 (発展的)

- 食べたモノの種類（例: 果物、家電、家具など）や、属性（例: 赤いもの、丸いもの）によって、HunToru くんが一時的にそのモノに関連する特徴を帯びるなど、視覚的なバリエーションを増やすことも検討します（例: 赤いコップを食べたら体が赤みを帯びる、丸いものを食べたら少し丸っこくなる）。

### 5.3. 開発者目線の実装・運用タスク

HunToru くんの魅力を最大限に引き出し、ユーザー体験に貢献するためには、以下のタスクが必要です。

#### 5.3.1. キャラクターデザインとモデル作成

- **モチーフキャラクターの確定**: 「HunToru」という名前から連想される、**捕食・成長を連想させる可愛らしいデザイン**を考案します（例: 胃袋のような形、口が大きい、シンプルで愛着がわくデザインなど）。
- **変化段階のデザイン**: 太り具合を示す`HunToru_debu_value`に応じた「太る/痩せる」といった状態変化の**複数の段階のデザイン**（イラスト、3D モデルなど）を準備します。例えば、痩せている状態、通常の状態、少し太っている状態、かなり太っている状態など、最低でも 3〜5 段階程度。
- **アニメーションデザイン**:
  - **登場アニメーション**: アプリ起動時やゲーム開始時の登場演出。
  - **食べるアニメーション**: ユーザーが撮影したモノを口に運び、消化するようなアニメーション。切り抜かれた画像が実際に口の中へ吸い込まれるような演出を検討。
  - **状態変化アニメーション**: 太る/痩せる変化がスムーズに移行するアニメーション。
  - **待機アニメーション**: ユーザーの操作を待っている間の可愛らしい仕草（瞬き、呼吸、ちょっとした動きなど）。

#### 5.3.2. キャラクター状態管理ロジックの実装

- **現在の状態管理**: HunToru くんの現在の「太り具合」を示す内部変数 `HunToru_debu_value` を定義します（デフォルト値：1）。
- **スコア連動ロジック**:
  - AI 判定スコア `label_score` を基に、`HunToru_debu_value` を以下の計算式で更新します。
    `HunToru_debu_value = HunToru_debu_value * (1 + label_score)`
  - 各難易度で得られるスコアのレンジや、ゲームのテンポを考慮し、増減の割合を調整します。
- **状態上限/下限**: `HunToru_debu_value`が過度に増減しないよう、最大値と最小値を設定します。
- **見た目の反映**: `HunToru_debu_value`に応じて、表示するキャラクターデザインの段階やアニメーションを切り替えるロジックを実装します。

#### 5.3.3. 画像表示とアニメーション連携

- **切り抜き画像の受け取り**: 画像処理フェーズで切り抜かれた「食べたモノ」の画像データを受け取る。
- **テクスチャ・スプライト適用**: 切り抜かれた画像を、HunToru くんが食べる際のアニメーション要素（例: 口元に移動する、体が膨らむ際のテクスチャとして使うなど）として動的に適用する。
- **アニメーション制御**: 状態変化や食べるアクションなど、各種アニメーションを滑らかに再生・停止する制御ロジックを実装します。

#### 5.3.4. サウンドエフェクト (UX 向上)

- **食べる音**: モノを食べる際のコミカルなサウンドエフェクト。
- **変化時の音**: 太る/痩せる変化に応じたポジティブ/ネガティブなサウンドエフェクト。
- **感情表現の音**: 嬉しそうな声、がっかりした声など、HunToru くんの感情を表現する短いサウンド。

#### 5.3.5. テストと調整

- **アニメーションの表示テスト**: 様々なデバイスでアニメーションがスムーズに再生されるか、描画崩れがないかを確認します。
- **状態変化のバランス調整**: ユーザーテストを通じて、HunToru くんの太る/痩せるスピードがゲームバランスとして適切か、ユーザーのモチベーションに繋がるかを確認し、必要に応じて`HunToru_debu_value`の増減量や段階を調整します。
- **キャラクターへの愛着形成**: ユーザーが HunToru くんに愛着を感じられるか、フィードバックを収集し、デザインや演出に反映します。
